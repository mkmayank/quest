Application layer - DNS, HTTP, Telnet, SSH, FTP, SNMP, SMTP, DHCP, RDP, NTP etc
    Layer 7: Application Layer  - data
    Layer 6: Presentation Layer
    Layer 5: Session Layer

Transport layer - TCP, UDP
    Layer 4: Transport Layer - segment / segment for TCP . datagram for UDP , packets, user datagram

Internet layer - IP, ICMP, ARP, RARP, IGMP
    Layer 3: Network Layer  - datagram

Link / Network Acess layer - Ethernet, Token Ring, FDDI, X.25, Frame Relay
    Layer 2: Data Link Layer    -   frame
    Layer 1: Physical Layer     -   bit, symbol

================================================================
* OSI model
Open Systems Interconnection (OSI) model

Application     -   allow access to network resources
Presentation    -   translate, encrypt, and compress data
Session         -   establish, manage, and terminate sessions
Transport       -   provide reliable process to process message delivery and error recovery
Network         -   move packets from source to destination to provide internetworking
Deta Link       -   organize bits into frames, provides hop-to-hop delivery
Physical        -   transmit bits over a medium, provide mechanical and electrical specifications

================================================================
Physical Layer (Layer 1)

    responsible for moving individual bits from one (node) to the next.

- Physical characteristics of interfaces and media ??? chapter 3
- Representation of bits (stream of bits)
    To be transmitted, bits must be encoded into signals—electrical or optical
    defines the type of encoding (how 0s and 1s are changed to signals)
- Data rate - transmission rate
- Synchronization of bits
- concerned with Line configuration
    - e.g.
        in point-to-point configuration two devices are connected through dedicated link
        multippoint configuratin, link is hared between several devices
- physical topology
    - e.g. mesh, star, ring, bus
- Transmission mode
    - e.g. simplex, half duplex, full duplex

================================================================
Data Link Layer (Layer 2)

    transforms the physical layer, a raw transmission facility, to a reliable link
    defines the protocol to establish and terminate a connection between two physically connected devices

- Framing
    divides the stream of bits received from the network layer into manageable data units called frames

- Physical addressing ?? mac
- Flow Control
    - e.g.
        if receiver data rate < sender data rate
        the data link layer imposes a flow control mechanism to prevent overwhelming the receiver
- Error control (detects and possibly corrects errors)
    - detect and retransmit damaged or lost frames
    - recognize duplicate frames
    - normally achieved through a trailer added to the end of the frame ???

================================================================
Network Layer (Layer 3)

    responsible for the source-to-destination delivery of a packet

data link layer oversees the delivery of the packet between two systems on the same network (link)
network layer ensures that each packet gets from its point of origin to its final destination
if system are on same link, there is no need for network layer

- Logical addressing
    - .e.g. IP ???
- Routing
    - routers or switch

================================================================
Transport Layer (layer 4)

    responsible for process-to-process delivery of the entire message

network layer oversees source-to-destination delivery of individual packets, does not recognize any relationship between those packets
transport layer ensures that the whole message arrives intact and in order

- Service-point addressing
    - service-point address (port address)
- Segmentation and reassembly
    - message is divided into transmittable segments
    - each segment contains a sequence number
    - sequence numbers helps to reassemble the message correctly at destination
        - identify and replace packets that were lost in transmission
- Connection control
    .e.g. connectionless , connection-oriented
- Flow control  (process-to-process)
- Error control (process-to-process)

================================================================
Session Layer (layer 5)

    provides the mechanism for opening, closing and managing a session between end-user application processes

- Dialog control
    - deciding whose turn it is to talk
        - halfduplex or full-duplex
        Simplex Sessions - TV Broadcasting, Radio Broadcasting, etc
        Half Duplex Sessions - CB Radio (Police Wireless), Walkie Talkie, etc
        Full Duplex Sessions - Telephone, Audio or Video Conferencing, etc
        identification of mode of communication for a session is called Dialog Control
    - dialog management is implemented via use of a data token
        - the token is sent back and forth, and a user may transmit only when it possesses the token
- Synchronization
    - move the two session entities into a known state
    - responsible for session checkpointing and recovery
    - transport layer handles only communication errors, synchronization deals with upper layer errors
      e.g.
        in a file transfer, the transport layer might deliver data correctly,
        but the application layer might be unable to write the file because the file system is full
    - Synchronization is achieved through the use of sequence numbers. The ISO protocols provide both major and minor synchronization points.
        When resynchronizing, one can only go back as far as the previous major synchronization point.
        In addition, major synchronization points are acknowledged through explicit messages (making their use expensive)
    e.g. if a system is sending a file of 2,000 pages,
        it is advisable to insert checkpoints after every 100 pages to ensure that each 100-page unit is received and acknowledged independently
        In this case,if a crash happens during the transmission of page 523, the only pages that need to be resent after system recovery are pages 501 to 523
        Pages previous to 501 need not be resent
    e.g.
        web conferencing, in which the streams of audio and video must be synchronous to avoid so-called lip sync problems
        TV programs, where streams of audio and video need to be seamlessly merged and transitioned from one to the other to avoid silent airtime or excessive overlap.

================================================================
Presentation Layer (layer 6)

    define the data format and encryption

- Encoding
    - responsible for interoperability between different encoding methods
        presentation layer(sender) information (sender-dependent format) => common format
        presentation layer(reciver) common format => information (receiver-dependent format)
- Encryption
- Compression

================================================================
Application Layer (layer 7)

    real process to process information

================================================================

session layer (along with the presentation layer) add services to the transport layer that are likely to be of use to applications,
so that each application doesn't have to provide its own implementation

################################################################
* TCP/IP model

TCP/IP Protocol Suite is normally shown as a five-layer stack
it only defines the three upper layers
    network, transport, and application layers

no specific protocol for the physical layer
no specific protocol for the data link layer
    supports all of the standard and proprietary protocols
    communication is also between two hops or nodes

    node to node

network layer
    internet protocol (IP)

    responsible for sending individual datagrams
    datagrams travel independently of each other
    no track of routes
    no facility for reordering once they arrive at destination

    end to end
    network layers of the routers can inspect the source and destination of the packet for
    finding the best route, but they are not allowed to change the contents of the packet

    every node need to have network layer

transport layer
    User Datagram Protocol (UDP)
    Transmission Control Protocol (TCP)
    Stream Control Transmission Protocol (SCTP)

    responsible for delivering the whole message

    end to end
    only end nodes(computers) need to have transport layer

no session or presentation layer
    if some of the functionalities mentioned in the session and presentation are needed
    it can be included in the development of that piece of software

application layer
    end to end
===============================================================

physical layer      - bit
data link layer     - frame                                 -   physical address
network layer       - datagram                              -   logical address
transport layer     - segment or user datagram or packet    -   port address
application layer   - message                               -   application specific address

===============================================================

end to end / node to node
        in node to node, packet may be changed various time in between
        in end to end, packet remains same

################################################################
* Addressing

    Four levels of addresses are used in TCP/IP protocols:
        1. physical address ( link address )
        2. logical address
        3. port address
        4. application-specific address

physical address
    e.g. mac address
    - address of node in network
    - size and format varies dependending on network
    - unicast or multicast or broadcast (supports depends on network)
    - changes from hop to hop

logical address
    e.g. ip
    - address of host in network
    - 32 bit (IPv4), 64 bit (IPv6)
    - unicast or multicast or broadcast (limitations on broadcast address ???)
    - remains same

port address
    - address of process
    - 16 bits in length
    - remains same

application-specific address
    e.g. mail ids, urls


########################################################################
########################################################################

Error Control
    mechanism for detecting corrupted, lost, or duplicate datagrams
    includes a mechanism for correcting errors after they have been detected

Flow control
    regulates the amount of data a source can send without overwhelming the receiver

Congestion Control
    in a connectionless Network
        - signaling
            backward signaling
                bit is set in the acknowledgment to inform the sender
            forward signaling
                bit is set in the packet traveling to warn the receiver
                receiver then may inform the upper layer protocol, which in turn may inform the source

        - choke packet
            special packet that can be sent from a router to the sender when it encounters congestion
            e.g.
            network layer uses ICMP packet to source to slow down

        - rank the packets by their importance in the whole message

    in a Connection-Oriented Network (easy)
        - sender and the receiver may agree to a level of traffic when they setup the virtual circuit

################################################################
################################################################
* Project 802

    project of the Institute of Electrical and Electronics Engineers (IEEE)
    for defining LAN and WAN standards and technologies

    IEEE divides data link layer into 2 sublayers:
        1. logical link control (LLC)
        2. media access control (MAC)

- Medium access control (MAC) layer
    responsible for gaining access to a medium and permission to transmit data

- Logical link control (LLC) layer
    responsible for identifying and encapsulating network layer protocols
    controls error checking
    frame synchronization

=================================================================
Ethernet 802.3 (Carrier Sense Multiple Access with Collision Detection)

- unreliable medium
    does not provide any mechanism for acknowledging received frames

- Ethernet frame

    64 bytes - 1518 bytes (without preamble and SFD)

    contains seven fields:
        1. preamble                     - 7 bytes   (physical layer header)
        2. Start frame delimiter        - 1 byte    (physical layer header)
        3. Destination address          - 6 byte
        4. Sourde address               - 6 byte
        5. length or type of data unit  - 2 bytes
        6. upper-layer data             - 46 - 1500 bytes
        7. CRC                          - 4 bytes

    Preamble
        - alerts the receiving system to the coming frame & enables it to synchronize its input timing
        - pattern provides only an alert and a timing pulse
        - pattern allows the stations to miss some bits at the beginning of the frame
        - actually added at the physical layer and is not (formally) part of the frame

    Start frame delimiter (SFD)
        - signals beginning of the frame , fixed e.g, 10101011
        - warns the station or stations that this is the last chance for synchronization
        - last 2 bits are 11 and alert the receiver that the next field is the destination address
        - SFD is added at the physical layer

    Destination address
    Source address

    Length or type
        - original ethernet uses this field as type to define upper layer via MAC frame
        - IEEE standard uses it to denote length of data

    Data

    CRC
        - contains error detection information

Each station on an Ethernet network has its own network interface card (NIC)
    - 6 byte physical address (48 bits) (normally written in hexadecimal notation)
    - data link address / physical address / MAC address (Media Access Control)

The least significant bit of the first byte defines the type of address
    0 => unicast
    1 => multicast

    all 48 bits are 1 => broadcast

=================================================================
original Ethernet with 10-Mbps which is history
    - access method for traditional ethernet
        CSMA/CD carrier sense multiple access with collision detection
    - rarely used

    - logical topology is always a bus
    - medium is shared between stations and only one station at a time can use it
        all stations receive a frame sent by a station
        real destination keeps the frame while the rest drop it

    - requires that each station first listen to the medium

    - collision may happen due to propagation delay
        a station may sense the medium and find it idle,
        only because the first bit sent by another station has not yet been received

    - if there is a collision, the frame is sent again.
    - each station continues to send bits in the frame until it detects the collision

    - for CSMA/CD to work, need a restriction on the frame size
    - before sending the last bit of the frame
        the sending station must detect a collision if any and abort the transmission
    - b/c once the entire frame is sent, does not keep a copy of the frame and does not monitor the line for collision detection

    - transmission time must be at least two times the maximum propagation time

    e.g.
        if maximum propagation time is 25.6 micro second
            frame transmission time = 25.6 micro second * 2 = 51.2 us
            min size of fram  = 10M bps * 51.2 us
                              = 10 * 10^6 bps * 51.2 * 10^-6 us
                              = 512 bits
                              = 64 bytes

Standard Ethernet implementations:

Characteristics     10Base5             10Base2         10Base-T        10Base-F
Medium              Thick Coax          Thin coax       2 UTP           2 Fiber
Maximum length      500 m                185 m          100 m           2000 m

UTP unshielded twist pair
=================================================================

Fast Ethernet (802.3u) 1995 - 100Mbps
    - only star topology is kept
        half-duplex approach
            the stations are connected via a hub
            access method is the same (CSMA/CD)
        full-duplex approach
            the connection is made via a switch with buffers at each port
            no need for CSMA/CD
            implementations keep CSMA/CD for backward compatibility

    - autonegotiation
        allows two devices to negotiate the mode or data rate of operation
        e.g.
            10Mbps can communicate with 100Mbps
        allow one device to have multiple capabilities
        allow a station to check a hub’s capabilities

Gigabit Ethernet (802.3z) 1998 - 1000Mbps
    - half duplex is rare

Ten-Gigabit Ethernet (802.3ae) 2002-06 - 10 Gbps

==================================================================
Frame Bursting

to allow longer network , min frame length is increased (Carrier extension)
and if shorter data to be sent padding will be needed

Carrier extension is very inefficient if we have a series of short frames to send
to improve efficiency, frame bursting is used
Instead of adding an extension to each frame, multiple frames are sent with padding between frames

==================================================================
Wireless LAN 802.11

The standard defines two kinds of services:
    1. basic service set (BSS)
    2. extended service set (ESS)

BSS
    - building block of a wireless LAN
    - made of
            stationary or mobile wireless stations and
            an optional central base station, known as the access point (AP)

    - ad hoc architecture
        BSS without AP (stand alone network)
        cannot send data to other BSSs

        stations can form a network without the need of an AP
        they can locate one another and agree to be part of a BSS

        stations within BSS can communicate with each other

    - iinfrastructure network
        BSS with an AP

ESS
    - made up of two or more BSS with APs
    - APs are connected through a distribution system, which can be any LAN such as ethernet


Stations cna be of three types based on their mobility:
    no-transition           - within on BSS
    BSS-transition          - moving across BSSs but within ESS
    ESS-transition mobility - moving across ESSs

Wireless LANs cannot implement CSMA/CD for three reasons:
    1. costly and increased bandwidth requirement
            as station must be able to send data and receive collision signals at the same time
    2. hidden station problem
    3. Signal fading due to distance
            could prevent a station at one end from hearing a collision at the other end

==================================================================
CSMA/CA (carrier sense multiple access with collision avoidance)

    before sending frame
    source station senses the medium by checking the energy level at the carrier frequency
    if medium is continuously idle for DCF Interframe Space (DIFS) duration
        then the station sends a control frame called the request to send (RTS)

    after receiving the RTS
        destination station sends a control frame clear to send (CTS)
        after SIFS

    source station sends data after SIFS

    destination station sends an acknowledgment after SIFS

Short Interframe Space (SIFS)
    ??? not understanded properly
    amount of time in microseconds required for a wireless interface to process a received frame
    and to respond with a response frame

Network Allocation Vector (NAV)

    - other stations defer sending their data if one station acquires access

    - station includes duration of time it needs to occupy, while sending an RTS frame
    - stations affected by this transmission create a timer called a network allocation vector (NAV)
        - which shows how much time must pass before these stations are allowed to check for idleness

In case collision during the time when RTS or CTS control frames are in transition (handshaking period)
CTS won't be received and sender will try again

Fragmentation
    division of a large frame into smaller ones

==================================================================
802.11 Frame format ???
Addressing  ???
==================================================================
Hidden Station Problem
    it is solved

    B==A==C
    lets say B is in range of A but not C and vice versa
    C will never know about B RTS
    buy when A send CTS , it will also be recived by C
    and C will know that some hidden node is sending data and C will not send data

Exposed Station Problem
    not solved

    B==A==C==D
    if A wants to send data to B and C to D
    only one can send

==================================================================
Bluetooth (802.15) , wireless personal area network (PAN) operable in room or hall
    - ad-hoc network
    - bluetooth network can not be large

2 types of networks
    1. Piconet
    2. Scatternet

Piconet
    - upto 8 stations
        - one is primary
        - rest are secondary
    - all synchronize their clocks and hopping sequence with primary
    - additional 8 secondaries can be in parked state
    - communication can be one-to-one or one-to-many

Scatternet
    - piconet combined to form scatternet
    - secondary Station in one piconet can be primary in another piconet

Frame format ???

#########################################################################
56K Modems ???
DSL ( Digital subscriber line) ???
ADSL (asymmetric DSL) ???
Cable Modem ???
T lines ???
SONET (Synchronous Optical Network) ???
PPP (Point-to-Point Protocol ) ???

#########################################################################
Switched WANS ???
    X.25 ??
    Frame Relay ???
    ATM (asynchronous tranfer mode) ???

#########################################################################
Devices

Router or 3 layered switch      3 layered device (physical, datalink, network)
Bridge or 2 layered switch      2 layered device (physical, data link)
Repeater or hub                 1 layer device (physical)

Repeater
    - receives signal before it becomes too weak or corrupted,
      regenerates and sends the refreshed signal
    - no intelligence / filtering capabilities
    - just egenerate the corrupted bits and send them out from every port

Bridge
    - regenerates the signal it receives
    - bridge can check the physical addresses
    - has table to take filtering decisions

    Transparent bridge
        - has dynamic table (learns from frame movements)

two-layer switch
    - sophisticated bridge with faster forwarding capability

Router
    - regenerates the signal it receives
    - checks the physical addresses
    - checks the network layer addresses
    - internetworking device
    - has a physical and logical (IP) address for each of its interfaces
    - changes the physical address of the packet (both source and destination) when it forwards the packet

three-layer switch
    - low cost, high port, for offices, ???

A repeater or a bridge connects segments of a LAN.
A router connects independent LANs or WANs to create an internetwork (internet)

        bridge                            switch
do not have buffers	                has a buffer for each link connected to it
do not perform error checking	    perform error checking

#########################################################################
#########################################################################

Switching

    decsion to select one of output port at connecting device

Circuit Switching
    - physical circuit (or channel) is established before the delivery of the message
    - whole message is sent without being divided into packets
    - never implemented at network layer
    - mostly used at physical layer

    e.g. old telephone lines

Packet Switching
    - todays network layer is packet-switched network
    - message at is divided into manageable packets and assembled at destination

network layer is designed as a packet-switched network

connectionless service
    - network layer protocol treats each packet independently
    - forwarding decision is based on the destination address of the packet

connection-oriented service
    - there is a relation between all packets belonging to a message
    - forwarding decision is based on the label of the packet
    - a virtual connection is set up to define the path for the datagrams before delievery of datagrams

    - packet must contain source, destination and flow label (virtual circuit identifier)

    - there is no need for source and destination addresses, only flow label is good
      they are there if part of route is connectionless

    To create a connection-oriented servicee
    three-phase process is used
        1. setup
            - source and destination addresses of the sender and receiver is used to make table entries for the connection-oriented service
            - router creates an entry for a virtual circuit
                - Two auxiliary packets exchanged between the sender and the receiver
                    1. request packet
                    2. acknowledgment packet

                routers creates label in its table on recieving request packet and forwards it
                    info in table
                    incoming port, label_this, outgoing port

                destination on recieving request packet sends back acknowledgment packet with its label
                acknowledgment packet completes the entries in the switching tables

                routers fills label in its table the recieving label and forwards it previous router
                    info in table
                    incoming port, label_this, outgoing port, label_next

        2. data transfer
                sender sends datagram with recieving label
                next router read its table match with label_this and changes label to label_next and sends

        3. teardown
            - source sends special packet called a teardown packet
            - destination responds witha confirmation packet
            - routers deleted entries from table

        e.g.
        tables in routers
                    Incoming            Outgoing
                    Port Label          Port  Label
        router1     1    14             3     66
        router2     1    66             3     22
        router3     1    22             4     77

        source will send datagrams with label 14
        destination will send datagrams with label 77


Connection less service is most dominant in today's internet
may be future
===================================================================================
* Network Layer Services

at the source

    1. packetizing
    2. finding the logical address of the next hop
    3. finding the physical (MAC) address of the next hop
    4. fragmenting the datagram if necessary.

    Packetizing
        encapsulate the data coming from the upper layer in a datagram
            adds header which contains
                logical source address of the packet
                logical destination address of the packet
                information about fragmentation
                protocol ID of the protocol that has requested the service
                data length, and possibly some options
            also includes a checksum that is calculated only over the datagram header

        the upper layer protocol only provides the logical destination
        the logical source address comes from the network layer itself

    Finding Logical Address of Next Hop
        network layer consult a routing table to find the logical address of the next hop

    Finding MAC Address of Next Hop
        network layer uses another table to map the next-hop logical address to the MAC address
        Address Resolution Protocol (ARP)

    Fragmentation
        datagram is fragmented to smaller units before being passed to the data link layer based on MTU of data link layer
        data is fragmented and header is repeated
            some more information added to the header to define the position of the fragment in the whole datagram

    MTU Maximum transfer unit

------

at each router
    finding next-hop logical address
    finding next-hop MAC address
    fragmentation
    validation of datagram checksum ???

-------

at the destination
    validation
        after validating each datagram, the data is extracted from each fragment and stored
    assembling
        when all fragments have arrived, the data are reassembled and delivered to the upper layer

    uses reassembly timer, if timer is expired ???
        all data fragments are destroyed and an error message is sent that all the fragmented datagram need to be resent

-------------------------------------------
Error Control
    Network layer doesn't provides
        checksum of header prevents delievery to wrong destination
        but not of corrupt data if it happens
        ICMP ???

Flow Control
    Network layer doesn't provides
        upper layers can implement buffers
        flow control is provided in upper layers

Congestion Control
    network layer uses ICMP packet to source to slow down

Routing
    ???

Security
    IPSec ???

==========================================================================
* IPv4
    unique in Internet
    32 bit number

    4 bytes ( 4 * 8 ) 32 bit

    2^8 . 2^8 . 2^8 . 2^8
    0-255 . 0-255 . 0-255 . 0-255

    notation
        (base 2) binary notation
        (base 16) dotted-decimal notation
        (base 256) hexadecimal notation

    number of address between two ip addresses
        146.102.32.255 , 146.102.29.0
        Number of addresses
        = (0 × 256^3 + 0 × 256^2 + 3 × 256^1 + 255 × 256^0 ) + 1 = 1024

------------
Classfull addressing (1981)
Classless Inter-Domain Routing (1993)

Classfull addressing
    5 classes (A,B,C,D,E)
    classes A, B, C are divided into netid and hostid
    class D addresses are made of one block, used for multicasting
    class E addresses was reserved for future purposes

Classfull address
    class A -   leading bits 0  -   size of nw 2^7 ( first 8 bits )     -   CIDR /8

        start     0.  0.  0.  0 =   00000000.00000000.00000000.00000000
        end     127.255.255.255 =   01111111.11111111.11111111.11111111
                                    0nnnnnnn.HHHHHHHH.HHHHHHHH.HHHHHHHH

    class B -   leading bits 10 -   size of nw 2^14 ( first 16 bits )   -   CIDR /16

        start   128.  0.  0.  0 =   10000000.00000000.00000000.00000000
        end     191.255.255.255 =   10111111.11111111.11111111.11111111
                                    10nnnnnn.nnnnnnnn.HHHHHHHH.HHHHHHHH

    class C -   leading bits 110 -  size of nw 2^21 ( first 24 bits )   -   CIDR /24

        start   192.  0.  0.  0 =   11000000.00000000.00000000.00000000
        end     223.255.255.255 =   11011111.11111111.11111111.11111111
                                    110nnnnn.nnnnnnnn.nnnnnnnn.HHHHHHHH

    class D -   leading bits 1110   -   special

        start   224.  0.  0.  0 =   11100000.00000000.00000000.00000000
        end     239.255.255.255 =   11101111.11111111.11111111.11111111
                                    1110XXXX.XXXXXXXX.XXXXXXXX.XXXXXXXX

    class E -   leading bits 1111   -   special

        start   240.  0.  0.  0 =   11110000.00000000.00000000.00000000
        end     255.255.255.255 =   11111111.11111111.11111111.11111111
                                    1111XXXX.XXXXXXXX.XXXXXXXX.XXXXXXXX

    starting and ending address are reserved in every class

-----------

Classless addressing
    - no class
    - variable-length blocks
    - number of addresses in a block needs to be power of 2
        block is divided into 2 parts
            1. prefix - network
            2. suffix - host
    - prefix length in classless addressing can be 1 to 32
    - need to include prefix length with every address
        while in classfull, address tells which block it is part of and netid can be easily find
    - slash notation (classless interdomain routing, CIDR)
        prefix is added to address separated by dash
    - number of addresses in the block
        = 2^ (32 - prefix length)

-------------------
Special addresses

    all zero address
        0.0.0.0/32
        - when host doesn't know its own address (use in DHCP protocol)

    all ones address Limited Broadcast Address
        255.255.255.255/32
        - to send packet to all host in a local network, router discard the packet

    loopback address
        127.0.0.0/8
        - using this address, packet never leaves the machine
        - to pint itself

    private addresses
        10.0.0.0/8
        172.16.0.0/12
        169.254.0.0/16
        192.168.0.0/16

    multicast addresses
        224.0.0.0/4

no logical reason behind choosing these addresses ???

Special addresses in each block

    network address
        first address defines the network address (not any host) (with suffix set all to 0s)

    direct broadcast address
        last address in block (with suffix set all to 1s)
        usually used by router to send packet to all hosts in a network
        can only be used as destination address

-------------------

Network address
    - identifier of the network each network is identified by its network address

Network Mask
    - in classful addressing is a 32-bit number with n leftmost bits all set to 1s and (32 − n) rightmost bits all set to 0s.

network address = destination address AND network mask

Three-Level Addressing: Subnetting
    - splitting a block to smaller blocks is referred to as subnetting
    - network is divided into several smaller subnetworks (subnets) with each subnetwork having its own subnetwork address

Subnet Mask

Subnetting increases the length of the netid and decreases the length of hostid
to divide a network into s subnetworks (s must be a power of 2)

    subnetid length = netid length + log2 s

    e.g.
    to divide class B into 4 subnet
        subnetid length = 16 + log2 4 = 18
    so subnet mask = 255.255.192.0 (18 1s and 14 0s)

Supernetting
    - combine serveral class C blocks to create a larger range of addresses

Supernet Mask

Supernetting decreases the length of the netid and increases the length of hostid
to combine c blocks of class C (c must be a power of 2)

    supernetid length = netid length - log2 c
    e.g.
    to combine 8 blocks
        supernetid length = 24 - log2 8 = 21
    so supernet mask = 255.255.248.0 (21 1s and 11 0s)

number of addresses in each subnetwork should be a power of 2
prefix length for each subnetwork
     = prefix length of block + log 2 (total addresses in block/ addressess in subnet)

=======================
* NAT Network Address Translation
    provides mapping between private and universal addresses
    allows site to use
        internal private addresses and
        one global internel address for communication with rest of world

    private network uses private addresses
    router that connects network to global address uses one private address and one global address
    rest of world sees only router public address

    router replaces
        all outgoing packets source address to public address
        all incoming packets destination address to private address

    NAT table
    private_address     private_port    external_address    external_port


=======================
IPv6 ???
=======================

==============================================================================
Delivery
    sender uses the next hops IP address to find the physical address (ARP protocol)
    and then gives datagram to data link layer

    direct delievery
    indirect delivery

--------

Forwarding
    - delivery to the next hop

    forwarding based on destination address of the packet
    forwarding based on the label attached to the packet

Forwarding techniques

Next-Hop Method
    - routing table holds only the address of the next hop
      entries of a routing table must be consistent with each other

host specific routin
    - routing table holds destination host addresses

Network specific method
    - routing table holds only network addressess

Default method
    - routing table holds specific entries and default entries

Routing table
Mask    Network_Address     Next_hop_address    interface

---------------

MPLS
    - Multi-Protocol Label Switching
    can forward the packet based on the destination address
    can forward the packet based on the label

IPV4 doesn't support label
IPV6 provides

to achieve forwarding based on label
    encapsulate the IPv4 packet in an MPLS packet
    MPLS layer can be added in between data link and network layer

============================================================================
IP datagram
IP is an unreliable and connectionless datagram protocol

IP datagram
    20 - 65535 bytes
    header 20-60
    rest is data

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version|  IHL  |Type of Service|          Total Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Identification        |Flags|      Fragment Offset    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Time to Live |    Protocol   |         Header Checksum       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Source Address                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Destination Address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


Ip datagram header  20 - 60 bytes

    1. version                  4 bits
    2. header length            4 bits
    3. servicetype              8 bits
    4. total length             16 bits     - 2^16 - 1 = 65535 max size of datagram
    5. identification           16 bits
    6. flags                    3 bits
    7. fragmentation offset     13 bits
    8. time to live             8 bits
    9. protocol                 16 bits
    10. header checksum         16 bits
    11. source ip address       32 bits
    12. destination ip address  32 bits
    13. options                 0 - 40 bytes


    identification, flags, fragmentation offset used in fragmentation

    ttl is decremented by each hop
    datagram is discarded if ttl reaches 0

    protocol defines higher level protocol that uses it (TCP, UDP, ICMP, IGMP, ...)
    specifies final destination protocol to which the IP datagram should be delivered

------------------------------------------------
Fragmentation
    why
        because frame size (MTU maximum transfer unit) depends upon protocol used by data link layer
    router
        decapsulates datagram from the frame it receives
        process it
        encapsulates it to another frame

    due to various different implementation of physical layers at different point of route
    fragmented datagram may itself be fragmented if it encounters a network with an even smaller MTU

    datagram can be fragmented by
        source host or
        any router in the path

    reassembly of the datagram
        is done only by the destination host
            because each fragment becomes an independent datagram

    reassembly during transmission will have inefficiency

    during fragmentation
        - fields which are changed
            flags
            fragmentation offset
            total length

            checksum recalculated
            option filed may or may not be changed

        - rest fields remains same

    only data in a datagram is fragmented

    ----------------------

    identification field
        - identifies datagram orignating from the source host
        - Identification + source IP uniquely define a datagram

        - all fragmented datagrams have same identification
        - all fragments having same Identification value assembled into one datagram

    flags
        1. first bit (not used)
        2. second bit (do not fragment bit)
            value 1 ??? when is requirement
                datagram must not get fragmented
                    if fragmentation is neccessary
                        discards the datagram and send ICMP error message to source
            value 0
                can be fragmentated if necessary
        3. third bit (more fragment bit)
            value 1
                not the last fragment, there are more fragments afer this one
            value 0
                this is last fragment

    fragmentation offset
        - relative position of this fragment with respect to the whole datagram
        - offset of the data in the original datagram measured in units of 8 bytes
        - forces to choose the size of each fragment so that the first byte number is divisible by 8

        e.g.
            datagram with data size of 4000 bytes
            fragmenting into 3 fragments will have offset :
                first (0 to 1399)       offset      0/8         = 0
                second (1400 to 2799)   offset      1400/8      = 175
                third (2800 to 3999)    offset      2800/8      = 350

                lets say second fragment is also fragemented into two fragments

                    second_1 (1400 - 2199)      offset  1400/8  = 175
                    second_2 (2200 - 2799)      offset  2200/8  = 275

            so 4 fragments are:
                    bytes         offset         more fragment flag
                0-1399             0                 1
                1400-2199        175                 1
                2200-2799        275                 1
                2800-3999        350                 0

            at assembly
                first fragement
                    will always have offset 0
                    more fragment flag is 1, so more fragment
                second fragment
                    offset
                        = total size of recieved fragments / 8
                        = 1400 / 8 = 175
                    so second segment is the one with offset 175
                    more fragment flag is 1, so more fragment
                third segment
                    offset = 2200 / 8 = 275
                    more fragment flag is 1, so more fragment
                fourth segment
                    offset = 2800 / 8 = 350
                    more fragment flag is 0, so lats segment

                reassembly done

        being 13 bit 2^13 = 8192, fragmentation can not represent sequence of bytes grater than 8191

---------------------------------------------------
options of ip header (0-40 bytes)
    not required
    composed of
        1. type field          1 byte
        2. length filed        1 byte
        3. value field         variable
???
Record-Route Option
    - to record internet routers that handles the datagram
    - upto 9 router ip addresses
    ping -R
strict-source-route option
    - source to predetermine a route for the datagram
    traceroute -G
loose-source-route option
    - similar to the strict source route, but it is more relaxed
    - each router in the list must be visited, but the datagram can visit other routers as well
    traceroute -g
timestamp option
    - to record the time of datagram processing by a route

------------------------------------------------------
Checksum
To create the checksum the sender does the following:
    ❑ The packet is divided into k sections, each of n bits.
    ❑ All sections are added together using one’s complement arithmetic.
    ❑ The final result is complemented to make the checksum.

Checksum Calculation at the Receiver
    packet is deivied into k sections, each of n bits
    adds all sections
    complements the result
    If final result is 0
        the packet is accepted
    otherwise, it is
        rejected

in IP packet
    checksum filed is set to 0
    entrire header is divided into 16bit sections and added together
    result is complemented and inserted into checksum field

-----------------------------------------------------------------------
Security issues:
    Packet Sniffing
        - cannot be stopped
    Packet Modification
        - can be detected using a data integrity mechanism at higher level
    IP Spoofing
        - can be prevented using an origin authentication mechanism

IPSec ???

=======================================================================
* ARP Address Resolution Protocol

before the IP protocol can deliver a packet from a source host to the destination host
it needs to know how to deliver it to the next hop first

Static mapping

Dynamic Mapping
    Address Resolution Protocol (ARP)
        maps a logical address to a physical address
    Reverse Address Resolution Protocol (RARP) (deprecated in favor of DHCP)
        maps a physical address to a logical address


IP datagram must be encapsulated in a frame to be able to pass through the physical network
sender needs the physical address of the receiver

ARP
    - accepts a logical address from the IP protocol
    - maps the address to the corresponding physical address
    - pass it to the data link layer

    request-response protocol
        messages are encapsulated by a link layer protocol
        communicated within the boundaries of a single network
        ARP is in link layer or inbewteen network and link layer

    ARP query packet, includes
        physical and IP addresses of the sender
        IP address of the receiver
    query is broadcast over the network

    only the intended recipient recognizes its IP address and sends back an ARP response packet
        response packet contains
        recipient’s IP and physical addresses
    packet is unicast directly to the inquirer using the physical address

ARP request is broadcast
ARP reply is unicast

ARP packet format

    1. Hardware Type                16 bit              define type of network( e.g ethernet is 1)
    2. Protocol Type                16 bit              for IPv4 0x0800
    3. Hardware length              8 bit
    4. Protocol length              8 bit
    5. operation                    16 bit              request or reply
    6. sender Hardware address      variable length     6 bytes for ethernet
    7. sender protocol address      variable length     4 bytes for IP
    8. target hardware address      variable length     6 bytes for ethernet    , 0 in case of request
    9. target protocol address      variable length     4 bytes for IP

ARP packet is encapsulated in frame as data
frame
    type is set to ARP type (known number , e.g 0x0806 in ethernet)
    destination address is set to

-----------------------------------
Proxy ARP
    used for subnetting
    router is responsible for reply for mutiple IPs as its own hardware address
    hosts doesn't even needs to know that subnetting is done

=======================================================================
* ICMPv4 Internet Control Message Protocol

    why
        - IP protocol has no error-reporting or error-correcting mechanism
            - in case of router discarding a datagram because
                it cannot find a router to the final destination, or
                because the time-to-live field has a zero value
            - in case final destination host must discard all fragments of a datagram because
                it has not received all fragments within a predetermined time limit

        - IP protocol lacks a mechanism for host and management queries
            - host sometimes needs to determine if a router or another host is alive
            - sometimes a network manager needs information from another host or router

ICMP is a network layer protocol
its messages are not passed directly to the data link layer
messages are encapsulated inside IP datagrams before going to the lower layer

value of the protocol field in the IP datagram is 1 for ICMP message

ICMP always reports error messages to the original source
    - it doesn't correct errors, but report them

No ICMP error message is generated:
    - in response to a datagram carrying an ICMP error message
    - for a fragmented datagram that is not the first fragment
    - for a datagram having a multicast address
    - for a datagram having a special address such as 127.0.0.0 or 0.0.0.0
------------

ICMP messages are divided into two broad categories
    1. error-reporting messages
        - Destination unreachable
        - Source quench                 - deprecated
        - Time exceeded
        - Parameter problem
        - Redirection
    2. query messages
        - Echo request or reply
        - Timestamp request or reply

Message Format, differs for each message type ( first four bytes are common to all)

    1. Type             8bits           type of message
    2. Code             8 bits          reason for particular message types
    3. Checksum         16 bits         checksum is calculated over the entire message
    4. Rest of header   4 bytes         specific
    5. Data section

maximum length of ICMP messages is 576 bytes

all error messages contains a data section, which includes
    - IP header of the original datagram
    - first 8 bytes of data in that datagram
        (first 8 bytes tells UDP, TCP protocol , port number and sequence numbers)


----------------
ping
    - sends ICMP echo request messages (type: 8, code: 0)
    - the destination, if alive, responds with ICMP echo reply messages
    - sets the identifier field to and keep incremented by one
    - inserts the sending time in the data section of the message to caclulate RTT(round trip time)

traceroute
    - sends UDP packet with TTL 0, 1, 2, ...
    - router returns time exceeded ICMP message
    also for destination to discard
        destination port is set to one that is not supported by the UDP protocol
        destnation returns destination unreachable message

===========================================================

Mobile IP
    - home address          permanent
    - care-of address       keep changes ,as host moves

    - home agent
    - foriegn agent

Double Crossing
Triangle routing

===========================================================
===========================================================
===========================================================
* Routing Protocol
    - for dynamic routing tables
    - lets routers in the internet inform each other of changes


Autonomous system (AS)
    - group of networks and routers under the authority of a single administration.
    - one routing protocol cannot handle the task of updating the routing tables of all routers
        being internet is too large
    - an internet is divided into autonomous systems. An autonomous system (AS) is a

intra-domain routing
    - routing inside an autonomous system
    RIP(routing information protocol)       - distance vector protocol
    OSPF(open shortest path first)          - link state protocol

inter-domain routing
    - routing between autonomous systems
    BGP(Border Gatway Protocol)             - path vector protocol

????

####################################################################################
####################################################################################
####################################################################################

* Transport Layer (Layer 4)
    - process to process communication
    - port numbers are integers between 0 and 65,535

socket address
    - combination of an IP address and a port

user datagrams, segments, or packets

Multiplexing (at source) and Demultiplexing (at destination)

Error control at the transport layer is responsible to
    1. Detect and discard corrupted packets.
    2. Keep track of lost and discarded packets and resend them.
    3. Recognize duplicate packets and discard them.
    4. Buffer out-of-order packets until the missing packets arrive.

    For error control, the sequence numbers are modulo 2^m ,
        where m is the size of the sequence number field in bits.
    e.g. for m = 4
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...

Flow Control
    having buffer at sender and reciever side

Congestion Control
    Open-Loop Congestion Control
    Retransmission Policy
    Window Policy
    Acknowledgment Policy
    Closed-Loop Congestion Control

Stop-and-Wait protocol
    flow control is achieved by forcing the sender to wait for an acknowledgment
    error control is achieved by discarding corrupted packets
        letting the sender resend unacknowledged packets when the timer expires.

bandwidth-delay product

Go-Back-N Protocol ???
    send several packets before receiving acknowledgments
    but the receiver can only buffer one packet
    the size of the send window must be less than 2^m
    the size of the receive window is always 1.

Selective-Repeat (SR) protocol ???
    resends only selective packets, those that are actually lost

=============================================================

UDP     message-oriented        non-reliable
TCP     byte-oriented           reliable
SCTP    message-oriented        reliable message-oriented protocol

=============================================================
* UDP User Datagram Protocol

    - connectionless, unreliable transport protocol
    - no acknowledgment for received packets
    - if UDP detects an error in the received packet, it silently drops it

    - does not add anything to the services of IP
        except for providing process-to-process communication instead of host-to-host communication

    - very simple protocol using a minimum of overhead
    - if a process wants to send a small message and does not care much about reliability
    - sending a small message using UDP takes much less interaction between the sender and receiver than using TCP

-----------

UDP user datagram (8 to 65535 bytes)
    8 bytes header
    data

UDP packets, called user datagrams, have a fixed-size header of 8 bytes

        0      7 8     15 16    23 24    31
        +--------+--------+--------+--------+
        |     Source      |   Destination   |
        |      Port       |      Port       |
        +--------+--------+--------+--------+
        |                 |                 |
        |     Length      |    Checksum     |
        +--------+--------+--------+--------+


    length  -   total length of user datagram
                can be calculated from IP header too
                    UDP length = IP length − IP header’s length

                designers of the UDP protocol felt
                    length in UDP header is efficient rather than caclulating from IP header
                    also IP header is dropped in layer 3 , in UDP layer IP header info is not passed

    checksum    to detect errors over the entire user datagram (header plus data)

----------
all user datagrams are independent of each other
process can send only < 65,507 bytes (65535 - 8) of data, UDP cannot chop

no flow control
no error control
no congestion control

Checksum calculation
    - different from the one for IP
    - optional
    - checksum includes three sections
        1. pseudoheader
                - part of IP packet in which user datagram is to be encapsulated
                - gives protection against misrouted datagrams
                - never transmitted, just used for checksum
        2. UDP header
        3. data

                0      7 8     15 16    23 24    31
                +--------+--------+--------+--------+
                |          source address           |
                +--------+--------+--------+--------+
                |        destination address        |
                +--------+--------+--------+--------+
                |  zero  |protocol|   UDP length    |
                +--------+--------+--------+--------+

                +--------+--------+--------+--------+
                |     Source      |   Destination   |
                |      Port       |      Port       |
                +--------+--------+--------+--------+
                |                 |                 |
                |     Length      |    Checksum     |
                +--------+--------+--------+--------+

                +--------+--------+--------+--------+
                |               Data                |
                |    paddig is added to make        |
                |    data mutiple of 16             |
                +--------+--------+--------+--------+

    ???
    https://serverfault.com/questions/910713/how-does-udp-sockets-know-which-source-address-to-respond-to

Encapsulation
    - processes                 > message + socket address, length of data      > UDP
    - UDP       adds header     > user datagrams + socket address               > IP
    - IP        adds header     > datagrams > data link layer                   > data link layer
    - link      adds header     > frame                                         > physical layer

Decapsulation
    - link      drops header    > datagram                                      > IP
    - IP        drops header    > user datagrams + sender, receiver IP          > UDP
    - UDP       drops header    > data + socket address                         > process

Queuing
    - incoming and an outgoing queue
    - only incoming queue

---------------------------

===============================================================================
* TCP Transmission Control Protocol
    - reliable, stream-oriented protocol

    - two processes seem to be connected by an imaginary “tube” that carries their bytes across the Internet
    - sending process produces the stream of bytes and the receiving process consumes them

    - full-duplex service

----------
Sending and Receiving Buffers

    sending and the receiving processes may not write or read data at the same rate
    TCP needs buffers for storage at each side
        1. sending buffer
        2. receiving buffer

    sender, the buffer has three types of chambers
        1. empty area are that can be filled by the sending process
        2. area holding bytes that have been sent but not yet acknowledged
        3. area containing bytes to be sent

    receiver, two chambers
        1. empty area to be filled by bytes received from the network
        2. area containing received bytes that can be read by the receiving process

Segments
    - IP needs to send data in packets and not stream of bytes
    - TCP groups a number of bytes together into a packet called a segment

    - segments are not necessarily all the same size

Multiplexing and Demultiplexing

Connection-Oriented Service

Numbering System
    - there is no field for a segment number in the segment header
    - there are two fields
        1. sequence number
        2. acknowledgment number
    - these two fields refer to a byte number and not a segment number

    Byte Number
        - TCP numbers all data bytes that are transmitted in a connection
        - numbering is independent in each direction
        - numbering starts with an arbitrarily generated number (between 0 and 2^32 -1)
            e.g.
            if number is 1057
            total data is 6000 bytes
                bytes are numbered from 1057 to 7056

    Sequence Number
        - defines the number assigned to the first data byte contained in that segment

    Acknowledgment Number
        - defines the number of the next byte a party expects to receive

Flow Control
    - byte-oriented

Error Control
    - byte oriented

Congestion Control
-----------------------------------------------------
TCP Segment
    header (20 - 60 bytes)
    data

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |          Source Port          |       Destination Port        |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |                        Sequence Number                        |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |                    Acknowledgment Number                      |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |header |           |U|A|P|R|S|F|                               |
        |length | Reserved  |R|C|S|S|Y|I|            Window             |
        |       |           |G|K|H|T|N|N|                               |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |           Checksum            |         Urgent Pointer        |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |                    Options                    |    Padding    |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |                             data                              |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    - acknowledgment and data can be piggybacked together

    header length indicates number of 4 byte words (i.e 5(5*4=20) to 15(15*4=60))

        URG: Urgent pointer is valid
        ACK: Acknowledgment is valid
        PSH: Request for push
        RST: Reset the connection
        SYN: Synchronize sequence numbers
        FIN: Terminate the connection

    checksum calculation is same as UDP, but mandatory

-------------------------------------------------------------------
TCP connection
    1. connection establishment
    2. data transfer
    3. connection termination

Connection Establishment
    Three-Way Handshake

        first segment
            - client sends the first segment, SYN segment
            - segment is for synchronization of sequence numbers
            - this sequence number is called the initial sequence number(ISN)
            - carries no data

        second segment
            - server sends the second segment, SYN + ACK segment
            - segment has a dual purpose
                - SYN segment for communication in the other direction
                - acknowledges the first segment
            - define the window size
            - carries no data

        third segment
            - client sends the third segment, ACK segment
            - acknowledges the second segment
            - defines the window size
            - carries no data ( some implementations may include data )

    e.g.
        client      ->      seg: x              S              -> server
        client      <-      seq: y  ack: x+1, A S wnd: a       <- server
        client      ->      seq: x  ack: y+1, A   wnd: b       -> server

    Simultaneous Open ???
        - a rare situation may occur when both processes issue an active open
        - both TCPs transmit a SYN + ACK segment to each other
        - one single connection is established between them

    SYN Flooding Attack
        - send a large number of SYN segments to a server by spoofing IP
        - a denial of service attack
        to alleviate
            - limit connection requests during a specified period of time
            - try to filter out datagrams coming from unwanted source addresses
            - postpone resource allocation until the server verifies valid IP address (SCTP ???)

Data Transfer
    - bidirectional data transfer can happen

    Pushing Data
        - PSH bit
        - program that communicates interactively with another application program on the other end
            .e.g.
                one site wants to send a keystroke to the application at the other site and receive an immediate response

        - sender requests a push operation
            - sending TCP must not wait for the window to be filled
            - it must create a segment and send it immediately

        - TCP can choose whether or not to use this feature

    Urgent Data
        - URG bit


Connection Termination
    - any party can close the connection
    two options for connection termination
        1. three-way handshaking
        2. four-way handshaking with a half-close option

    three-way handshaking

        first segment
            - client sends the FIN segment
            - may include last chunk of data

        second segment
            - servers sends FIN + ACK segment
            - may include last chunk of data

        third segment
            - client sends ACK segment
            - cannot carry data

        e.g.
            client      ->      seg: x     ack: y      A F      -> server
            client      <-      seq: y     ack: x+1    A F      <- server
            client      ->      seq: x     ack: y+1    A        -> server

    Half-Close
        when one end stops sending data while still receiving data (known as half close)

Connection Reset
    any one end may
        - deny a connection request
        - may abort an existing connection
        - may terminate an idle connection
    All of these are done with the RST (reset) flag

==========================================================================
Cumulative Acknowledgment (ACK) ????
Selective Acknowledgment (SACK) ????

Flow Control ????
    windows size can be asked to changed

Error Control ????

Retransmission
    - segment is stored in a queue until it is acknowledged


    Retransmission after RTO
        - if retransmission time-out (RTO) times out
            resends the segments and restart timer
        - RTO is dynamic in TCP and is updated based on the round-trip time (RTT) of segments

    Retransmission after Three Duplicate ACK Segments
        - Fast retransmission
        - if when the sender receives three duplicate ACKs for the first segment in the queue
            that segment is retransmitted

Silly window syndrome ????
    - problem when sender sends or reciver consumes slow
    - and window size becomes too low that data is smaller tha header
        results in very inefficient transmission


Deadlock Created by Lost Acknowledgment ?????
    - receiver sends an acknowledgment with rwnd set to 0
    - receiver wants to remove the restriction ans send ACK segment with window size
    - and this ack segment lost
    - sender will wait for an acknowledgment that announces the nonzero rwnd
    - receiver thinks that the sender has received this and is waiting for data
    - each end is waiting for a response from the other end and nothing is happening

    - a persistence timer was designed for this ???

Congestion control ???

Congestion Policy
    three phases
        1. slow start
        2. congestion avoidance
        3. congestion detection

    slow start phase
        sender starts with a slow rate of transmission
            but increases the rate rapidly to reach a threshold
        when threshold is reached
            the rate of increase is reduced
        if ever congestion is detected
            sender goes back to the slow start or congestion avoidance phase

        size of the congestion window (cwnd) starts with one maximum segment size (MSS)
            MSS is determined during connection establishment using option
        sise of window increases one MSS each time one acknowledgment arrives or by 1

    slow start algorithm
        size of the congestion window increases exponentially until it reaches a threshold
    congestion avoidance algorithm
        size of the congestion window increases additively until congestion is detected

=================================================================
TCP timers ???
    1. Retransmission Timer
    2. Persistence Timer
    3. Keepalive Timer
    4. TIME-WAIT Timer

options ????

==================================================================
SCTP ?????

########################################################################
########################################################################
########################################################################